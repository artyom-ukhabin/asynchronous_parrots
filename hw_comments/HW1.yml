Исправления с прошлого реквеста:
  - Спроектировал систему еще один раз, сравнил и исправил исходную.
  ES:
    - Извлечены новые ES-события из бизнес-требований, что обогатило модель данных.
  Схема доменов: 
    - удален домен Notifier - в данном случае это не домен, а чисто технический сервис из урока.
  Схема сервисов: 
    - Проставлены синхронные коммуникации извне и сервиса авторизации с остальными сервисами.
    - Убран синхронный запрос из аккаунтинга в таск-трекер - это premature решение проблемы целостности. Проблемы еще нет и решение может быть другим.

Полученные знания:
  ES:
    - В первом варианте дизайна ES-команды сразу были побиты по доменам - на самом деле это нужно делать только после формирования цепочек - лишний прайминг.
  Модель данных:
    - Не все данные из ES формируют Entity на модели. Пример - сумма в команде Log account credit, которая является VO (аргументам) и не существует в модели.
  Выделение доменов:
    - Домены бьются по цепочкам ES, но не обязательно как одна цепочка - один домен. Границы доменов рисуются по цепочкам - основная идея в том, что набор связанных команд находится по одну сторону от разделения и попадает в один контекст/домен. Находящиеся по одну сторону границ части разных цепочек и формируют контекст/домен.
    - Вероятно, на этом шаге так же используется видение независимого использования сервиса с доменом при падении другого.
    - Предположительно, контекст - выделяемая область логически связанных терминов.
    - События извлекаются также из кажущихся требований о чтении - так получились команды домена аналитики.
  Домены -> сервисы:
    - Notifier в моих схемах - пример того самого чисто технического сервиса из урока. Его не существует на уровне доменов.
  Коммуникации:
    - В уроке показано, что бизнес-команды = синхронные коммуникации извне для каждого сервиса.
    - Также в уроке показано что сервис авторизации синхронно коммуницирует с остальными сервисами.
    - Бизнесовые коммуникации полностью или почти полностью получаются из ES, CUD - из модели данных.  

Комментарии:
  - Физическая выплата денег может происходить в команде Clear Purse. Если имеется задумка сделать отдельный технический сервер по выплатам - нужно будет разбить команду на две, забиндить физическую выплату на событие из первой подкоманды и соблюсти распределенную транзакцию.

Вопросы:
  - Разобраться с выделением доменов из ES и модели данных.
  - Хватает ли одной информации из ES чтоб спроектировать модель данных или нужно повторно смотреть на требования - упускаются требования на чтение?
  - ES-сущности в поле данных должны содержать как входные, так и выходные данные, чтоб лучше формировать модель данных.
  - Не понятно, по каким условиям выделяются составные части основных сущностей (типа статус задачи) на модели данных и в чем смысл их выделения.

--------------------------------------------

Исправления после разбора домашки:
  - Добавлены пропущенные ES-команды, вынесены небизнесовые команды/query, изменен нейминг. Попробовал для целей обучения взять схему с разделением команд Create и Assign, Shuffle и Assign, хоть и есть сомнения, особенно во втором.
  - Добавлена забытая сущность Account в домене аналитики в модели данных, изменен нейминг
  - Исправлена схема коммуникаций

Знания после разбора домашки:
  Домены:
    - Выделение абстракции авторизации - уровень доменов. Это позволяют сделать пропущенные команды "Register Account" и "Change Account Role".
  ES-команды:
    - ES - работа с бизнесом, команды должны быть только бизнесовыми. Хоть термин "Аудитлог" и может быть бизнесовым, "Добавить в аудит лог" - не принадлежащий бизнесу нейминг технической реализации. Правильный вариант - "Зарегистрировать выплату".
     (Мои Log Purse Change неправильны -> Make a transaction? Если да - не стоит буквально понимать требования и стоит убирать оттуда технические команды)
    - "Register Account" - бизнес-команда, "Register balance" - нет. Регистрация баланса необходима нам для сервиса аккаунтинга (биллинга) - техническая реализация системы. Бизнес смысла либо не имеет, либо он уже включен в понятие "Зарегистрировать аккаунт". Поэтому создание баланса привязывается на CUD-событие технического создания аккаунта - дополнительный функционал, чтоб система работала.
     - Команда SetCost - не бизнес, потому что нет реального менеджера, который устанавливал бы в админке цену задачи. В наших требованиях это делается системой автоматически.
       "Конец дня" при этом реальный внешний актор в системе и порождает бизнес-команды.
     - Query - система говорит, что в бутылке есть вода, Команды - открыть крышку -> выпить воду. Команда = "Действие над". Query не меняет состояние системы, а только читает его, команда - всегда меняет.
       ES - получение внешних бизнес-событий в системе, Query/Read Model - какими данными мы оперируем.
     - Стоит проверять команды на составные части - так в моей неправильной небизнесовой команде "Create task" могут скрываться две объединенные в бизнес-транзакцию атомарные операции "Зарегистрировать задачу" и "Назначить задачу". Такое разделение не обязательно однозначно, но помнить про атомарность стоит.
       Команда "Поменять исполнителей" в такой схеме может быть представлена как команды "Сменить исполнителей" и переиспользованная "Назначить задачу".
    - Роли = условия на более низком уровне, которые не стоит учитывать сейчас, как и было на уроке. По факту, это ограничения, которые делают из длинной ES-цепочки более короткую. То же самое относится и к условиям типа "делать только для положительного баланса". Отсутствие доступа != отсутствие команды.
  ES-события:
    - Событие - глагол в прошедшем времени. Бизнес-событие - что произошло с точки зрения бизнеса, CUD - операция над ресурсом. Popug.Authorized - не CUD, Task.Created, AuditLogCreated, Balance.Changed, Money.SetCost (см. выше)- не бизнес.
    - CUD-событие и Business-события порождают разные процессы и не могут быть взаимозаменяемы.
      Task.Created (CUD) -> Расчет цены задачи в аккаунтинге
      Task.Added (Business) -> Assign Task/ничего.
  Модель данных:
    - Желательно поддерживать один источник правды для данных. Если таски обновляются и в таск-менеджере, и аккаунтинге - не понятно, как синхронизировать приходящие из разных мест события об апдейте.
    - Направление стрелок на схеме модели данных - принадлежность. Account -> role, роль принадлежит аккаунту.
  Домен аккаунтинга:
   - Правильный нейминг - AuditLog -> Транзакция. Деньги не могут храниться в изменяемых полях, нужен список транзакций. Неизбежна двойная запись - одна колонка на начисление, другая на списание. 100/0 - заработал 100$, 100/50 - заработал 100 и разбил вазу за 50 - заработал 50.
  - Баланс - закешированное значение суммы всех транзакций.
  - Контейнер, содержащий транзакции за определенный период времени (день) - Billing Cycle. Закрытие биллинг цикла означает выплату = создание новой транзакции "0/сумма выплат за цикл". Сначала транзакция попадает в список, и уже она запускает выплату.
  - Исходя из предыдущего пункта - транзакции бывают двух видов: списание/начисление и выплата.
  - Выделяется сущность выплаты, которая формируется по закрытию цикла. Связана с Биллинг Циклом и Транзакцией.
  (Разобраться как это влияет на Update Manager Income - как было в его случае с ценой и таской? Если понадобится цена в таск-трекере - что они делали, как ходили в прайс за ценой?)
  - Нотификация пользователя и списание денег оба запускаются закрытием Billing Cycle и являются параллельными, а не последовательными, потому что подразумевает, что мы отправляем нотификацию деньги *придут*, а не *уже есть*. К тому же в отдельный сервис он думает выделить именно процесс выплат (чисто технический?).
  Коммуникации:
    - В общем случае не видит проблемы в посылке всего агрегата задачи аккаунтингу по коммуникациям - отвечает на вопрос о посылке только айдишников в мой сервис нотификаций - (пока) избыточно. Данные вообще имеют цену - здравый смысл.
      (Второй фактор - быстродействие?)
    - Посылать много маленьких событий типа [Task.Reassigned]/[BillingCycle.Closed] или одно большое с массивом - вопрос потребностей. В разных случаях лучше разное.
    - При отправке бизнес-сообщения о завершении задачи, может быть не обязательно отправлять аккаунт, завершивший задачу - он уже есть в биллинге из сообщения об ассайне. Зависит от уровня консистентности - как мы обрабатываем приход бизнесов и CUD-событий в разном порядке.

--------------------------------------------

Итоговые выводы:
  - В общем случае, для построения модели данных одного ES недостаточно - так по моему ES не задетекчен баланс в аналитике. Для правильного построения модели необходимо читать условия второй раз, иначе упускаются простые Read Model.
  - Для правильного выделения доменов и построения модели данных, в ES в отдельном месте я также буду добавлять небизнесовые команды (таких пока нет), привязки на CUD-события и сложные (вычисляемые) Read Model.
    Общий алгоритм: написал ES, выделил бизнесовые события и Read Models -> нарисовал модель данных -> выделил домены -> увидел CUD-события -> добавил небизнесовые и привязки на CUD в ES.
  - Для построения бизнес-коммуникаций в схеме сервисов удобно использовать ES, для CUD-событий - модель данных.

Итоговые вопросы:
  - Удостовериться, что мой алгоритм позволяет правильно выделять домены и строить коммуникации.
  - Является ли событие логина бизнесовым?
  - Должна ли Data в ES-командах содержать как данные на вход, так и на выход? (У меня пока ответ - да)
  - Транзакции, балансы аккаунтов и общий менеджерский баланс находятся в одном домене, привязываться к CUD-событию создания транзакции не обязательно. Имеет ли смысл отражать это в моей версии ES?
  - Не понятно, по каким условиям выделяются составные части основных сущностей (типа статус задачи) на модели данных и в чем смысл их выделения.
    Варианты:
      - Теоретический - Просто удобство и наглядность, общего алгоритма нет. Скажем, хоть у меня нет в аккаунтинге роли аккаунта, было бы удобно ее выделить, точно так же, как в разборе в аккаунтинге выделяется дескрипшн на таске.
      - Практический - чтоб знать, что синкать в домен.
    В разборе говорит о выделении квадратиков как о самых основных частях сущности и добавляет дескрипшн в таске в аккаунтинге.
